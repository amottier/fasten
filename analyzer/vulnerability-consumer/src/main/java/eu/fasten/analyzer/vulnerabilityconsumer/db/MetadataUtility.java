/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityconsumer.db;

import eu.fasten.analyzer.vulnerabilityconsumer.utils.PURLPackage;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.Vulnerability;
import eu.fasten.core.data.Constants;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.FilesRecord;
import eu.fasten.server.connectors.PostgresConnector;
import org.jooq.*;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.sql.SQLException;
import java.util.*;
import java.util.stream.Collectors;

import static org.jooq.impl.DSL.field;

public class MetadataUtility {

    private Map<String, DSLContext> contexts;
    private final Logger logger = LoggerFactory.getLogger(MetadataUtility.class.getName());

    public MetadataUtility(Map<String, DSLContext> contexts) {
        this.contexts = contexts;
    }

    /**
     * Method to inject the information contained in a Vulnerability Object.
     * The following explains the logic used to insert the information:
     * First, the information at the package level is injected. This is done by looping through
     * all the purls contained in the object. We store the IDs of the package_version row.
     *
     * Second, we try to find the callables responsible.
     * @param v
     */
    public void injectVulnerabilityIntoDB(Vulnerability v) {
        logger.info("Injecting vulnerability " + v.getId() + " into the Database");
        var context = v.getPurls().size() > 0 ? getVulnerabilityEcosystem(v) : null;
        var pkgId = v.getPurls().size() > 0 ? getPackageId(v.getPurls().iterator().next(), context) : -1L;

        if (pkgId < 0) return;

        logger.info("Injecting into the DB Package Version with ID: " + pkgId);
//        injectPackageVersionVulnerability(v.toJson(), pkgId, context);

        var pkgVersionIds = new ArrayList<Long>();

        // Order in JSON Array is preserved
        // https://www.rfc-editor.org/rfc/rfc7159.txt
        for (String purl : v.getPurls()) {
            var pkgVersionId = getPackageVersionId(purl, context, pkgId);
            if (pkgVersionId > 0L) {
                pkgVersionIds.add(pkgVersionId);
            }
        }

        if (pkgVersionIds.size() == 0) return;

        var fastenUris = new HashSet<String>();
        var latestVersionId = pkgVersionIds.get(pkgVersionIds.size() - 1);

        for (Vulnerability.Patch p : v.getPatches()) {
            logger.info("Searching for callables in " + p.getFileName());
            fastenUris.addAll(getFastenUrisForPatch(p, latestVersionId, context));
        }

        logger.info("Collected " + fastenUris.size() + " vulnerable fasten_uris ids");

        for (String uri : fastenUris) {
            var callableIds = getCallableIdsForFastenUri(uri, context);
            // Inject the metadata in the callable row
            for (Long id : callableIds) {
                logger.info("Injecting into DB Callable with ID: " + id);
//                injectCallableVulnerability(v.toJson(), id, context);
            }
        }
    }

    /**
     * Finds the correct DSLContext for the vulnerability given.
     * @param v - vulnerability obj
     * @return DSLContext
     */
    private DSLContext getVulnerabilityEcosystem(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var purl = v.getPurls().iterator().next();
        var purlObj = PURLPackage.getObjectFromPurl(purl);
        return contexts.get(purlObj.getType());
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     * @param patch - that contains hunks with the changes to the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs to
     */
    private HashSet<String> getFastenUrisForPatch(Vulnerability.Patch patch, Long pkgVersionId, DSLContext context) {
        var fastenURIs = new HashSet<String>();

        // Get the fileID
        var fileId = getFileId(pkgVersionId, patch.getFileName(), context);
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        var moduleIds = getModuleIds(fileId, context);
        logger.info("Found " + moduleIds.size() + " modules corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            for (Integer lineNumber : patch.getLineNumbers()) {
                var fastenUrisInModule = getFastenUrisInModuleLines(moduleId, lineNumber, context);
                if (fastenUrisInModule.size() > 0) fastenURIs.addAll(fastenUrisInModule);
            }
        }
        return fastenURIs;
    }

    /**
     *
     * @param moduleId
     * @param lineNumber
     * @param context
     * @return
     */
    private List<String> getFastenUrisInModuleLines(Long moduleId, Integer lineNumber, DSLContext context) {
        var fasten_uris = context.select(Callables.CALLABLES.FASTEN_URI)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                .and(Callables.CALLABLES.LINE_START.le(lineNumber))
                .and(Callables.CALLABLES.LINE_END.ge(lineNumber))
                .fetch();

        return fasten_uris.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     * @param purl - follows purl specifications
     * @return negative if it cannot be found
     */
    private Long getPackageVersionId(String purl, DSLContext context, Long pkgId) {
        logger.info("Looking for package_version_id of " + purl);
        PURLPackage packageObject = PURLPackage.getObjectFromPurl(purl);

        assert pkgId > 0L;

        var pkgVersionRecord = context.select(PackageVersions.PACKAGE_VERSIONS.ID)
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(pkgId))
                .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(packageObject.getVersion()))
                .fetchOne();
        return pkgVersionRecord != null ? pkgVersionRecord.component1() : -1L;
    }

    /**
     * Retrieve the fileId of the file that was patched.
     * @param packageVersionId - Long pkg version ID
     * @param filepath - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath, DSLContext context) {
        var fileRecords = context.select(Files.FILES.ID, Files.FILES.PATH)
                .from(Files.FILES)
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .fetch();
        var file = fileRecords.stream()
                .filter(fr -> (!fr.component2().equals("") && filepath.contains(fr.component2())))
                .map(Record2::component1).collect(Collectors.toList());
        return file.size() > 0 ? file.get(0) : -1L;
    }

    /**
     * Gets the moduleId that corresponds to the file.
     * @param fileId - Long fileId
     * @return list of module Ids
     */
    public List<Long> getModuleIds(Long fileId, DSLContext context) {
        var moduleRecords = context.select(ModuleContents.MODULE_CONTENTS.MODULE_ID)
                .from(ModuleContents.MODULE_CONTENTS)
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetch();
        return moduleRecords.stream().map(Record1::component1).collect(Collectors.toList());
    }

    /**
     * Returns package ID given PURL and CONTEXT (forge).
     * @param purl - PURL string
     * @param context - DSLContext
     * @return -1L if not existing
     */
    public Long getPackageId(String purl, DSLContext context) {
        var pkgObj = PURLPackage.getObjectFromPurl(purl);
        var coordinate = pkgObj.getNamespace() + ":" + pkgObj.getName();
        var pkgRecord = context.select(Packages.PACKAGES.ID)
                .from(Packages.PACKAGES)
                .where(Packages.PACKAGES.PACKAGE_NAME.equal(coordinate))
                .fetchOne();
        return pkgRecord != null ? pkgRecord.component1() : -1L;
    }

    /**
     * Finds all the callable ids with the given fasten_uri
     * @param fastenUri - String
     * @return - List of ids of the callables
     */
    public List<Long> getCallableIdsForFastenUri(String fastenUri, DSLContext context) {
        var callableRecords = context.select(Callables.CALLABLES.ID)
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .fetch();
        return callableRecords.stream().map(Record1::component1).collect(Collectors.toList());
    }

    //////////////////////////
    //    DATABASE ACCESS   //
    //////////////////////////

    /**
     * Injects in the metadata of the callable vulnerability information.
     * @param vulnJSON - JSON of the vulnerability to inject
     * @param callId - Long ID of the callable interested
     */
    public void injectCallableVulnerability(String vulnJSON, Long callId, DSLContext context) {
        JSONObject vulnData = new JSONObject(vulnJSON);
        JSONArray vulns = new JSONArray();
        vulns.put(vulnData);

        var callableVulns = context.select(field("{0}->'vulnerabilities'",
                String.class, Callables.CALLABLES.METADATA))
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.ID.equal(callId))
                .fetchOne();

        // Check if the JSON contains vulnerabilities already
        boolean checkExistence = callableVulns.get(0) != null;

        if (checkExistence) {
            // There is already a vulnerability object --> append a new one
            context
                    .update(Callables.CALLABLES)
                    .set(Callables.CALLABLES.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   (metadata -> 'vulnerabilities')::jsonb || '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(Callables.CALLABLES.ID.equal(callId))
                    .execute();
        } else {
            // There is no vulnerability object --> add a new one
            context
                    .update(Callables.CALLABLES)
                    .set(Callables.CALLABLES.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(Callables.CALLABLES.ID.equal(callId))
                    .execute();
        }
    }

    /**
     * Injects in the metadata of the callable vulnerability information.
     * @param vulnJSON - JSON of the vulnerability to inject
     * @param pkgVersionId - Long ID of the packge_version interested
     */
    public void injectPackageVersionVulnerability(String vulnJSON, Long pkgVersionId, DSLContext context) {
        JSONObject vulnData = new JSONObject(vulnJSON);
        JSONArray vulns = new JSONArray();
        vulns.put(vulnData);

        var packageVersionVuln = context.select(field("{0}->'vulnerabilities'",
                String.class, PackageVersions.PACKAGE_VERSIONS.METADATA))
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .fetchOne();

        // Check if the JSON contains vulnerabilities already
        boolean checkExistence = packageVersionVuln.get(0) != null;

        if (checkExistence) {
            // There is already a vulnerability object --> append a new one
            context
                    .update(PackageVersions.PACKAGE_VERSIONS)
                    .set(PackageVersions.PACKAGE_VERSIONS.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   (metadata -> 'vulnerabilities')::jsonb || '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                    .execute();
        } else {
            // There is no vulnerability object --> add a new one
            context
                    .update(PackageVersions.PACKAGE_VERSIONS)
                    .set(PackageVersions.PACKAGE_VERSIONS.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                    .execute();
        }
    }

//    /**
//     * Finds all callables that belong to a module.
//     * @param moduleId - Long ID of the module
//     * @return - List of records
//     */
//    public Result<Record> getCallablesInModule(Long moduleId, DSLContext context) {
//        return context.select()
//                .from(Callables.CALLABLES)
//                .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
//                .fetch();
//    }


    public static void main(String[] args) throws SQLException {
//        var mvnDbUrl = "jdbc:postgresql:fasten_java";
//        var pypiDbUrl = "jdbc:postgresql:fasten_python";
//        var debianDbUrl = "jdbc:postgresql:fasten_c";
//        var dbUser = "fasten";
//
//        var mvnContext = PostgresConnector.getDSLContext(mvnDbUrl, dbUser);
//        var pypiContext = PostgresConnector.getDSLContext(pypiDbUrl, dbUser);
//        var debianContext = PostgresConnector.getDSLContext(debianDbUrl, dbUser);
//
//        var contexts = new HashMap<String, DSLContext>();
//        contexts.put(Constants.debianForge, debianContext);
//        contexts.put(Constants.mvnForge, mvnContext);
//        contexts.put(Constants.pypiForge, pypiContext);
//
//        MetadataUtility mu = new MetadataUtility(contexts);

//        Vulnerability v = new Vulnerability("test_02");
//        mu.injectPackageVersionVulnerability(v.toJson(), 48L);

        var condOne = "/java/Test.java";
        var full = "/src/main/java/Test.java";

//        System.out.println(condOne.(condOne));
    }
}
