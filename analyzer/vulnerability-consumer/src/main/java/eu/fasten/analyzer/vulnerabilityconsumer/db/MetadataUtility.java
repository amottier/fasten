/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package eu.fasten.analyzer.vulnerabilityconsumer.db;

import eu.fasten.analyzer.vulnerabilityconsumer.utils.CallableHolder;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.PURLPackage;
import eu.fasten.analyzer.vulnerabilityconsumer.utils.Vulnerability;
import eu.fasten.core.data.Constants;
import eu.fasten.core.data.metadatadb.codegen.tables.*;
import eu.fasten.core.data.metadatadb.codegen.tables.records.FilesRecord;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackageVersionsRecord;
import eu.fasten.core.data.metadatadb.codegen.tables.records.PackagesRecord;
import eu.fasten.server.connectors.PostgresConnector;
import org.jooq.DSLContext;
import org.jooq.JSONB;
import org.jooq.Record;
import org.jooq.Result;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.jooq.impl.DSL.field;

public class MetadataUtility {

    private Map<String, DSLContext> contexts;
    private final Logger logger = LoggerFactory.getLogger(MetadataUtility.class.getName());

    public MetadataUtility(Map<String, DSLContext> contexts) {
        this.contexts = contexts;
    }

    /**
     * Method to inject the information contained in a Vulnerability Object.
     * The following explains the logic used to insert the information:
     * First, the information at the package level is injected. This is done by looping through
     * all the purls contained in the object. We store the IDs of the package_version row.
     *
     * Second, we try to find the callables responsible.
     * @param v
     */
    public void injectVulnerabilityIntoDB(Vulnerability v) {
        logger.info("Injecting vulnerability " + v.getId() + " into the Database");
        // Inject all the info at the package-level and store packageVersionsId
        var pkgIds = new HashMap<String, Long>();
        var context = v.getPurls().size() > 0 ? getVulnerabilityEcosystem(v) : null;

        String lastVersionPurl = null;

        for (String purl : v.getPurls()) {
            Long pkgId = getPackageVersionId(purl, context);
            if (pkgId > 0) {
                logger.info("Injecting into the DB Package Version with ID: " + pkgId);
                // TODO: Pass the context as well
                injectPackageVersionVulnerability(v.toJson(), pkgId, context);
                pkgIds.put(purl, pkgId);

                // Compare to get the last version of purl
                if (lastVersionPurl != null) {
                    if (purl.compareTo(lastVersionPurl) > 0) {
                        lastVersionPurl = purl;
                    }
                } else {
                    lastVersionPurl = purl;
                }
            }
        }

        // For each of the files changed in the patches of the vulnerability
        // Find the FastenURI of the callable for the "first" purl
        // Propagate the same information at the callables for the other purls.
        if (lastVersionPurl != null) {
            for (Vulnerability.Patch patch : v.getPatches()) {
                logger.info("Searching for callables found in " + patch.getFileName()
                        + " in purl:" + lastVersionPurl);
                // Get the fasten_uri from the most recent vulnerable versions
                List<String> fastenURIs = getFastenUrisForVulnerability(patch, pkgIds.get(lastVersionPurl), context);
                // Propagate the same to the earlier versions changing the fastenURI
                logger.info("Found " + fastenURIs.size() + " fasten_uris to propagate in other versions");
                for (String uri : fastenURIs) {
                    // Get all the callables with the fasten_uri
                    List<Long> callableIds = getCallableIdsForFastenUri(uri, context);
                    // Inject the metadata in the callable row
                    for (Long id : callableIds) {
                        logger.info("Injecting into DB Callable with ID: " + id);
                        injectCallableVulnerability(v.toJson(), id, context);
                    }
                }
            }
        }
    }

    /**
     * Finds the correct DSLContext for the vulnerability given.
     * @param v - vulnerability obj
     * @return DSLContext
     */
    private DSLContext getVulnerabilityEcosystem(Vulnerability v) {
        assert v.getPurls().size() > 0;
        var purl = v.getPurls().iterator().next();
        var purlObj = PURLPackage.getObjectFromPurl(purl);
        return contexts.get(purlObj.getType());
    }

    /**
     * Given a file and a package version id, looks for each hunk in the file.
     * The fasten_uri of each callable that is found at the linenumber indicated in the hunk
     * is then stored and returned.
     * @param patch - that contains hunks with the changes to the file
     * @param pkgVersionId - Long - ID of the package version
     * @return List of fastenURIs to
     */
    private List<String> getFastenUrisForVulnerability(Vulnerability.Patch patch, Long pkgVersionId, DSLContext context) {
        List<String> fastenURIs = new ArrayList<>();

        // Get the fileID
        Long fileId = getFileId(pkgVersionId, patch.getFileName(), context);
        if (fileId < 0) return fastenURIs;

        // There could be more moduleIds for the same file
        List<Long> moduleIds = getModuleIds(fileId, context);
        logger.info("Found " + moduleIds.size() + " modules corresponding to file with id " + fileId);

        for (Long moduleId : moduleIds) {
            // Get callables information for the file
            // We need to know the fasten_uri + first + last
            List<CallableHolder> callableHolders = getCallablesInformation(moduleId, context);

            // For each hunk, get the line number and look in the callables table
            for (Integer lineNumber : patch.getLineNumbers()) {
                // Find the callable
                CallableHolder callable = getCallableThatContainsLine(callableHolders, lineNumber);
                if (callable != null) {
                    // Store fastenURI for later use
                    logger.info("Found vulnerable callable with fasten_uri: " + callable.getFastenURI());
                    fastenURIs.add(callable.getFastenURI());
                }
            }
        }

        return fastenURIs;
    }

    /**
     * Finds the callable that interests the specific line number we are looking at.
     * @param callableHolders - list of CallableHolders
     * @param lineNumber - Integer line number where the change was made
     * @return CallableHolder object
     */
    private CallableHolder getCallableThatContainsLine(List<CallableHolder> callableHolders, int lineNumber) {
        for (CallableHolder ch : callableHolders) {
            if (ch.getFirst() <= lineNumber && ch.getLast() >= lineNumber) {
                return ch;
            }
        }
        return null;
    }

    /**
     * Retrieves the callables information to use them later.
     * @param moduleId - Long ID of the file where the callable was changed.
     * @return Long ID of the callable (-1L if it cannot find it)
     */
    private List<CallableHolder> getCallablesInformation(Long moduleId, DSLContext context) {
        List<CallableHolder> calls = new ArrayList<>();
        // Get all the records with the moduleId given
        Result<Record> crs = getCallablesInModule(moduleId, context);
        for (Record cr : crs) {
            Long callableId = (Long) cr.get(0);
            String fastenUri = (String) cr.get(2);
            JSONB metadata = (JSONB) cr.get(5);
            JSONObject obj = new JSONObject(metadata.data());
            int first = (int) obj.get("first");
            int last = (int) obj.get("last");

            // Create callable object and store it
            CallableHolder ch = new CallableHolder(callableId,
                    fastenUri, first, last);

            calls.add(ch);
        }
        return calls;
    }

    /**
     * Retrieves the package_version_id given the purl of the package version.
     * @param purl - follows purl specifications
     * @return negative if it cannot be found
     */
    private Long getPackageVersionId(String purl, DSLContext context) {
        logger.info("Looking for package_version_id of " + purl);
        // Check if the package exists
        // Step 0: Brake down purl to get the information you need
        PURLPackage packageObject = PURLPackage.getObjectFromPurl(purl);

        // TODO: Refactor so that you do not need different logic
        if (packageObject.getType().equals("mvn")) {
            // Step 1: Find package ID of the package with specific name
            String mvnCoordinate = packageObject.getNamespace() + ":" + packageObject.getName();
            PackagesRecord packageRecord = getPackageIdFromCoordinate(
                    mvnCoordinate,
                    packageObject.getType(),
                    context);

            if (packageRecord != null) {
                // Find the package version record
                PackageVersionsRecord pgkVersionRecord = getPackageVersionIdFromVersion(
                        packageRecord.component1(),
                        packageObject.getVersion(),
                        context);

                if (pgkVersionRecord != null) {
                    return pgkVersionRecord.getId();
                }
            }
        }
        if (packageObject.getType().equals("PyPI")) {
            //TODO: Implement checks for Python packages to find the package
        }
        if (packageObject.getType().equals("debian")) {
            //TODO: Implement checks for Debian packages to find them in the DB
        }
        return -1L;
    }

    //////////////////////////
    //    DATABASE ACCESS   //
    //////////////////////////

    /**
     * Injects in the metadata of the callable vulnerability information.
     * @param vulnJSON - JSON of the vulnerability to inject
     * @param callId - Long ID of the callable interested
     */
    public void injectCallableVulnerability(String vulnJSON, Long callId, DSLContext context) {
        JSONObject vulnData = new JSONObject(vulnJSON);
        JSONArray vulns = new JSONArray();
        vulns.put(vulnData);

        var callableVulns = context.select(field("{0}->'vulnerabilities'",
                String.class, Callables.CALLABLES.METADATA))
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.ID.equal(callId))
                .fetchOne();

        // Check if the JSON contains vulnerabilities already
        boolean checkExistence = callableVulns.get(0) != null;

        if (checkExistence) {
            // There is already a vulnerability object --> append a new one
            context
                    .update(Callables.CALLABLES)
                    .set(Callables.CALLABLES.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   (metadata -> 'vulnerabilities')::jsonb || '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(Callables.CALLABLES.ID.equal(callId))
                    .execute();
        } else {
            // There is no vulnerability object --> add a new one
            context
                    .update(Callables.CALLABLES)
                    .set(Callables.CALLABLES.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(Callables.CALLABLES.ID.equal(callId))
                    .execute();
        }
    }

    /**
     * Injects in the metadata of the callable vulnerability information.
     * @param vulnJSON - JSON of the vulnerability to inject
     * @param pkgVersionId - Long ID of the packge_version interested
     */
    public void injectPackageVersionVulnerability(String vulnJSON, Long pkgVersionId, DSLContext context) {
        JSONObject vulnData = new JSONObject(vulnJSON);
        JSONArray vulns = new JSONArray();
        vulns.put(vulnData);

        var packageVersionVuln = context.select(field("{0}->'vulnerabilities'",
                String.class, PackageVersions.PACKAGE_VERSIONS.METADATA))
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                .fetchOne();

        // Check if the JSON contains vulnerabilities already
        boolean checkExistence = packageVersionVuln.get(0) != null;

        if (checkExistence) {
            // There is already a vulnerability object --> append a new one
            context
                    .update(PackageVersions.PACKAGE_VERSIONS)
                    .set(PackageVersions.PACKAGE_VERSIONS.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   (metadata -> 'vulnerabilities')::jsonb || '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                    .execute();
        } else {
            // There is no vulnerability object --> add a new one
            context
                    .update(PackageVersions.PACKAGE_VERSIONS)
                    .set(PackageVersions.PACKAGE_VERSIONS.METADATA,
                            field("jsonb_set(\n" +
                                    "  metadata,\n" +
                                    "  '{\"vulnerabilities\"}',\n" +
                                    "   '" + vulns.toString() + "'::jsonb," +
                                    "  true)", JSONB.class))
                    .where(PackageVersions.PACKAGE_VERSIONS.ID.equal(pkgVersionId))
                    .execute();
        }
    }

    /**
     * Finds all the callable ids with the given fasten_uri
     * @param fastenUri - String
     * @return - List of ids of the callables
     */
    public List<Long> getCallableIdsForFastenUri(String fastenUri, DSLContext context) {
        List<Long> ids = new ArrayList<>();

        Result<Record> crs = context.select()
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.FASTEN_URI.equal(fastenUri))
                .fetch();

        for (Record cr : crs) {
            ids.add((Long) cr.get(0));
        }

        return ids;
    }

    /**
     * Finds all callables that belong to a module.
     * @param moduleId - Long ID of the module
     * @return - List of records
     */
    public Result<Record> getCallablesInModule(Long moduleId, DSLContext context) {
        return context.select()
                .from(Callables.CALLABLES)
                .where(Callables.CALLABLES.MODULE_ID.equal(moduleId))
                .fetch();
    }

    /**
     * Retrieve the fileId of the file that was patched.
     * @param packageVersionId - Long pkg version ID
     * @param filepath - path to the file
     * @return -1 if the file cannot be found
     */
    public Long getFileId(Long packageVersionId, String filepath, DSLContext context) {
        // For the demo, just cut out the filename, without the path
        var splits = filepath.split("/");
        var filename = splits[splits.length - 1];

        FilesRecord fr = (FilesRecord) context.select()
                .from(Files.FILES)
                .where(Files.FILES.PACKAGE_VERSION_ID.equal(packageVersionId))
                .and(Files.FILES.PATH.equal(filename))
                .fetchOne();

        if (fr != null) {
            return fr.getId();
        } else {
            return -1L;
        }
    }

    /**
     * Gets the moduleId that corresponds to the file.
     * @param fileId - Long fileId
     * @return list of module Ids
     */
    public List<Long> getModuleIds(Long fileId, DSLContext context) {
        List<Long> moduleIds = new ArrayList<>();
        Result<Record> mcr = context.select()
                .from(ModuleContents.MODULE_CONTENTS)
                .where(ModuleContents.MODULE_CONTENTS.FILE_ID.equal(fileId))
                .fetch();

        for (Record record : mcr) {
            moduleIds.add((Long) record.get(0));
        }

        return moduleIds;
    }

    /**
     * Finds the ID of the package given the package given coordinate and forge.
     * Note, this is ecosystem agnostic
     * @param coordinate - includes information about the package
     * @param forge - ['mvn', 'PyPI', 'Debian']
     * @return - Record of the package if found
     */
    public PackagesRecord getPackageIdFromCoordinate(String coordinate, String forge, DSLContext context) {
        return (PackagesRecord) context.select()
                .from(Packages.PACKAGES)
                .where(Packages.PACKAGES.PACKAGE_NAME.equal(coordinate))
                .and(Packages.PACKAGES.FORGE.equal(forge))
                .fetchOne();
    }

    /**
     * Finds the ID of the package_version in all the version of the package.
     * @param pkgId - ID of the package
     * @param version - String of the version of the package_version
     * @return - Record of the package_version if found
     */
    public PackageVersionsRecord getPackageVersionIdFromVersion(Long pkgId, String version, DSLContext context) {
        return (PackageVersionsRecord) context.select()
                .from(PackageVersions.PACKAGE_VERSIONS)
                .where(PackageVersions.PACKAGE_VERSIONS.PACKAGE_ID.equal(pkgId))
                .and(PackageVersions.PACKAGE_VERSIONS.VERSION.equal(version))
                .fetchOne();
    }

    public static void main(String[] args) throws SQLException {
        var mvnDbUrl = "jdbc:postgresql:fasten_java";
        var pypiDbUrl = "jdbc:postgresql:fasten_python";
        var debianDbUrl = "jdbc:postgresql:fasten_c";
        var dbUser = "fasten";

        var mvnContext = PostgresConnector.getDSLContext(mvnDbUrl, dbUser);
        var pypiContext = PostgresConnector.getDSLContext(pypiDbUrl, dbUser);
        var debianContext = PostgresConnector.getDSLContext(debianDbUrl, dbUser);

        var contexts = new HashMap<String, DSLContext>();
        contexts.put(Constants.debianForge, debianContext);
        contexts.put(Constants.mvnForge, mvnContext);
        contexts.put(Constants.pypiForge, pypiContext);

        MetadataUtility mu = new MetadataUtility(contexts);

        Vulnerability v = new Vulnerability("test_02");
//        mu.injectPackageVersionVulnerability(v.toJson(), 48L);
    }
}
